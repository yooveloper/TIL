# 11장 원시 값과 객체의 비교

# ✅ 원시타입과 객체타입

원시 타입 값은 변경 불가능한 값(immutable value)

객체 타입의 값은 변경 가능한 값(mutable value)

원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다.

객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값이 저장된다.

pass by value : 원시값을 갖는 변수를 다른변수에 할당하면 원본의 원시값이 복사되어 전달된다

pass by reference : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다.

✅ 유사배열 객체

배열처럼 인덱스로 프로퍼티 값에 접근 가능하고 length 프로퍼티를 갖고 있는 객체

자바스크립트 문자열은 유사배열객체이고 for문으로 순회 가능.

✅ 값에 의한 전달

```jsx
**[ 예제 11-06 ]

var score = 80;
var copy = score;

score = 100;

console.log(score); // 100
console.log(copy); // 80**
```

# ✅ 객체

객체가 mutable 한 이유 ? 

객체는 동적으로 프로퍼티의 추가,삭제가 가능하기 때문에 확보해야 할 메모리 공간의 크기를 사전에 확정할수없음. 즉 메모리 확보 관점에서 원시타입과는 반대로 설계가 됨.

✅ 변경 가능한 값

```jsx
**[ 예제 11-11 ]

var person = {
	name: 'Lee'
};**

```

객체를 할당한 변수가 기억하는 메모리 주소를 통해 접근하면 참조값에 접근하는거임.

148페이지 그림 11-7 참고

# ✅ ❗ 얕은복사와 깊은 복사

객체를 프로퍼티로 갖는 객체의 경우 

```jsx
const o = {
	x: {
		y: 1	
	}
};

// 얕은 복사

const c1 = { ...o }; 
console.log(c1 === o); // false
console.log(c1.x === o.x); // true
```

# ✅ 참조에 의한 전달

객체를 가르키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다, ( 참조에 의한 전달 )

```jsx
**[ 예제 11-16 ]

var person = {
	name: 'Lee'
};

// 참조 값을 복사
var copy = person;

쉽게 말하면 person과 copy 식별자는 각각 다른 메모리 주소를 가르키고 있지만 둘다 
같은 메모리주소에 있는 { name: 'Lee' }; 객체를 참조하고 있음,

즉 n대 1 구조임 이렇게 되면 둘중 하나만 값이 바뀌어도 다른쪽도 똑같이 바뀜.**
```

```jsx
**[ 예제 11-18 ]

var person1 = {
	name: 'Lee'
};

var person2 = {
	name: 'Lee'
};

console.log(person1 === person2) // ? 둘은 서로 다른 메모리에 저장된 별도의 값 이기 때문에 false
console.log(person1.name === person2.name) // ? 객체안에 프로퍼티값을 참조하고 있기 때문에
값으로 평가될수 있는 표현식임. true**

```